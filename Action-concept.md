The `Action` concept is intended for implementing server commands that are available as web API methods.
The action's code will be executed in a single transaction,
so that in case of an error the whole action will be canceled (all-or-nothing).

Contents:

1. [Create an action](#create-an-action)
2. [Execute an action](#execute-an-action)
3. [How to use another class from an Action, without dependency injection](#how-to-use-another-class-from-an-action-without-dependency-injection)
4. [How to use another class from an Action, with dependency injection](#how-to-use-another-class-from-an-action-with-dependency-injection)
5. [BeforeAction concept](#beforeaction-concept)

## Create an action

The action can be implemented in two ways:

* Using the `Action` concept, which assumes writing the C# code directly in the .rhe script, or in a referenced .cs script file.
* Using the `ExtAction` concept, where the C# code is implemented in a plugin DLL.

Both ways have their pros and cons, and the choice depends on a situation. The `Action` concept is good for simple code snippets, while `ExtAction` is usually used for more complex implementations.

Tips:

* Action is executed in a single transaction. This means that it is not possible to log an exception error in the database.
* Row permission and other security claims are not checked inside the action.
  * The user needs to have permission to execute the action (has the *Execute* claim on the action),
      but not for the resources that are used inside the action. The code inside the action has access to all data.
  * The user's permission can be explicitly checked in the action by using `Common.RowPermissionsReadItems`
      and `Common.RowPermissionsWriteItems` filters, or `IAuthorizationManager` for checking security claims.
* Reference property in the action parameters will not be bound to the database by the ORM (the lazy-load is not supported).
  Also the whole entity cannot be sent as a reference property parameter.
* Exceptions that are cached in the action must be rethrown.

Example:

```C
Module Demo
{
    Action CreatePrincipal '(parameter, repository, userInfo) =>
    {
        var principal = new Common.Principal
        {
            ID = parameter.ID ?? Guid.NewGuid(),
            Name = parameter.Name
        };
        repository.Common.Principal.Insert(principal);
    }'
    {
        Guid ID;
        ShortString Name;
    }
}
```

## Execute an action

1. To execute an action from a client application, see Actions in
   [REST service specification](https://github.com/Rhetos/RestGenerator/blob/master/Readme.md#actions).
2. To execute an action in C# code from the Rhetos application,
   see [Using the Domain Object Model](Using-the-Domain-Object-Model#execute-action)

## How to use another class from an Action, without dependency injection

For Rhetos v4 and earlier versions, see [Using external code when developing DSL Actions](Using-external-code-when-developing-actions)
article to resolve issues with external dependencies.

For Rhetos v5 and later, code snippets in DSL scripts can directly reference custom classes from Rhetos app,
and the custom classes can reference the classes generated by Rhetos from the DSL scripts.

For example:

> Write a DSL Action that generates random books,
> but implement the code in a separate class, and call it from the DSL Action.

Solution:

1. Add a custom class RandomBookGenerator:

   ```cs
   using Rhetos.Dom.DefaultConcepts;
   using System;
   using System.Linq;

   namespace Bookstore.Service
   {
       public class RandomBookGenerator
       {
           public static void InsertBooks(Common.DomRepository repository, int? numberOfBooks)
           {
               var books = Enumerable.Range(0, numberOfBooks.Value)
                   .Select(x => new Book { Title = Guid.NewGuid().ToString() }); // Random title.
               repository.Bookstore.Book.Insert(books);
           }
       }
   }
   ```

2. Add the Action:

   ```cs
   Module Bookstore
   {
       Action InsertRandomBook
           '(parameter, repository, userInfo) => Bookstore.Service.RandomBookGenerator.InsertBooks(repository, parameter.NumberOfBooks)'
       {
           Integer NumberOfBooks;
       }
   }
   ```

## How to use another class from an Action, with dependency injection

1. Implement the custom class that requests other dependency injection components as constructor parameters.
   * For older applications (Rhetos v4 and earlier) that use DeployPackages, the class must be
     implemented in a separate C# library project (DLL).
2. Register your class to the [Autofac](https://autofac.org/) dependency injection container
   * See example of how to register a custom class directly in the Rhetos app:
     [ConfigureRhetosHostBuilder: ConfigureContainer](https://github.com/Rhetos/Bookstore/blob/5068c6cd8ba5b5c3eb0b596a2e6db991a47612ff/src/Bookstore.Service/Startup.cs#L146)
   * See example of how to register your plugin’s classes as a plugin module:
     [AutofacModuleConfiguration.cs](https://github.com/Rhetos/Rhetos/blob/master/src/Rhetos.CommonConcepts/Dom.DefaultConcepts/AutofacModuleConfiguration.cs)
   * Classes that depend on **user context** and **database connection** should be registered with `InstancePerLifetimeScope()`.
   * A singleton class should be registered to with `SingleInstance()`.
   * For other component registration options please refer to Autofac documentation:
     <https://autofaccn.readthedocs.io/en/latest/register/registration.html>
3. This class can then be used in the Action concept by adding it to the Action’s repository with RepositoryUses concept.
   See [RepositoryUses documentation](Low-level-object-model-concepts#repositoryuses).

## BeforeAction concept

If you are using an action that is already implemented in another package and you want to extend that action you can use the concept BeforeAction.
The code snippet of the BeforeAction concept will be executed before the Action is executed.

```C
BeforeAction Demo.CreatePrincipal.AppendUnderscoreToUsername '
    actionParameter.Name += "_";
';
```
